------------------------------------------------------------------------------
--! @authors: Jason Hunter, Kayvia Harriott, Tashna-Gail Williams
--! Created on: 2021-10-11
--! @version: 0.3
--! Last Updated: 2021-11-03 11:46:01
------------------------------------------------------------------------------

model scrumble

enum PlayerStatus {ONLINE, OFFLINE, AWAY, PLAYING}
enum ProfileState {PRIVATE, PUBLIC}
enum MatchType {RANKED, UNRANKED}
enum Category {ANIMAL, MUSIC, MOVIES, FOOD, BOOKS, COUNTRIES, NONE}
enum PlayType {PLAY, PASS, QUIT}
enum RequestStatus {PENDING, ACCEPTED, REJECTED, RECINDED, LOST}
enum MatchStatus {INPROGRESS, COMPLETE, ABANDONED}
enum RequestType {FRIEND, MESSAGE, MATCH}
enum BlockStatus {BLOCKED, UNBLOCKED}
-- enum MessageStatus {SEEN, UNSEEN}
-- enum ChatStatus {OPENED, CLOSED}
-- enum NotificationType {CHAT, REQUEST, REMINDER}


--! @TODO:
--!     For these 2 I'm thinking to add a period class to represent the
--!     duration the request was accepted for and allow periods to have no end
--!     date
--!     1. double check the date checking for valid match requests
--!     2. accepted requests must not have a recinded date
--!
--!     not matched with blocked players
--!     players cant interact with themselves
--!     Add classes to handle game support (claim, claim status enum,
--!         claims can be reporting players or bug reports)
--!     Add attributes to represent the rest of the player's profile data
--!     *add representations for message states (unseen, seen)
--!     *add different types of notifications (As suggested from Ourvle QNA)
--!
--!     DESIGN PATTERN REFINEMENTS
--!         Observer Pattern
--!             In the observer pattern, observables update observers when
--!             they change creating the effect that the observer is
--!             "watching" the observable. So observables have a list of their
--!             observers and call a method in the observer to let them know
--!             things changed. The observer would then execute different
--!             operations to update anything else that depends on the state
--!             of the observable object.
--!
--!         Suggestions for our system:
--!             +------------------------+
--!             | observer    | observes |
--!             +-------------+----------+
--!             | leaderboard | match    |
--!             | player      | match    |
--!             | match       | play     |
--!             | chat        | message  |
--!             +-------------+----------+
--!
--!         Note: Player observes match for status updates
--!         Note: If we have notifications then the notification class may
--!               need to observe anything that generated notifications
--!
--!         Singleton Pattern
--!             1 to one associations of the class with itself
--!
--!     ACL REFINEMENTS
--!         Role-Based ACL for Admins and users.
--!             Are we going to allow admins to play matches as well?

abstract class Identifiable
attributes
    id: String
end -- Identifiable

--from Class
class Date
attributes
    day: Integer init: 1
    month: Integer init: 1
    year: Integer init: 1900
operations
    initialise(d: Integer, m: Integer, y: Integer)
    begin
        self.day := d;
        self.month := m;
        self.year := y;
    end

    pre parametersHaveValidValues: isValid(d, m, y)
    post attributesCorrectlyUpdated:
        day = d and month = m and year = y

    -- Accessors
    getDay(): Integer = day
    getMonth(): Integer = month
    getYear(): Integer = year

    -- Mutators
    setDay(d: Integer)
    begin self.day := d; end
    pre newDateIsValid: isValid(d, month, year)
    post dayCorrectlyUpdated: day = d

    setMonth(m: Integer)
    begin self.month := m; end
    pre newDateIsValid: isValid(day, m, year)
    post monthCorrectlyUpdated: month = m

    setYear(y: Integer)
    begin self.year := y; end
    pre newDateIsValid: isValid(day, month, y)
    post yearCorrectlyUpdated: year = y

    -- returns true if all the attributes are not null, false otherwise
    isInitialised(): Boolean = day <> null and month <> null and
        year <> null
    post returnValueIsAccurate:
        result = Set{day <> null, month <> null, year <> null}
            ->forAll(t | t = true)

    -- returns true if self is before d, false otherwise
    before(d: Date): Boolean = ((year < d.year) or
        (year = d.year and month < d.month) or
        (year = d.year and month = d.month and day < d.day))
    pre bothAreInitialised: isInitialised() and d.isInitialised()
    pre bothAreValid: isValid(day, month, year) and
        isValid(d.day, d.month, d.year)
    post returnValueIsAccurate:
        result = ((year < d.year) or
            (year = d.year and month < d.month) or
            (year = d.year and month = d.month and day < d.day)) = true

    -- returns true if self has the same values as d, false otherwise
    equals(d: Date): Boolean = day = d.day and month = d.month and
        year = d.year
    pre bothAreInitialised: isInitialised() and d.isInitialised()
    pre bothAreValid: isValid(day, month, year) and
        isValid(d.day, d.month, d.year)
    post returnValueConditions:
        result = Set{day = d.day, month = d.month, year = d.year}
            ->forAll(t | t = true)

    -- returns true if self is after d, false otherwise
    after(d: Date): Boolean = (not equals(d)) and (not before(d))
    pre bothAreInitialised: isInitialised() and d.isInitialised()
    pre bothAreValid: isValid(day, month, year) and
        isValid(d.day, d.month, d.year)
    post returnValueIsAccurate:
        result = Set{not equals(d), not before(d)}->forAll(t | t = true)

    -- returns true if y is a leap year, false otherwise
    isLeapYear(y: Integer): Boolean =
        if (y.mod(400) = 0 or (y.mod(100) > 0 and y.mod(4) = 0)) then
                true
            else
                false
            endif
    pre yearIsValid: y <> null and y > 1900
    post returnValueIsAccurate: result = (y.mod(400) = 0 or
        (y.mod(100) > 0 and y.mod(4) = 0)) = true

    dayValid(v: Integer): Boolean = v >= 1 and v <= 31
    pre paramaterNotNull: v <> null
    post returnValueIsAccurate: result = v >= 1 and v <= 31

    monthValid(v: Integer): Boolean = v >= 1 and v <= 12
    pre paramaterNotNull: v <> null
    post returnValueIsAccurate: result = v >= 1 and v <= 12

    yearValid(v: Integer): Boolean = v > 1900
    pre paramaterNotNull: v <> null
    post returnValueIsAccurate: result = v > 1900

    dayAndMonthValid(d: Integer, m: Integer): Boolean =
        (Set{4, 6, 9, 11}->includes(m) implies d <= 30) and
        (Set{1, 3, 5, 7, 8, 10, 12}->includes(m) implies d <= 31)
    pre dayIsValid: dayValid(d)
    pre monthIsValid: monthValid(m)
    post returnValueIsAccurate: result =
        (Set{4, 6, 9, 11}->includes(m) implies d < 31) and
        (Set{1, 3, 5, 7, 8, 10, 12}->includes(m) implies d < 32)

    febValid(d: Integer, y: Integer): Boolean =
        (isLeapYear(y) implies d <= 29) and
        (not isLeapYear(y) implies d <= 28)
    pre dayIsValid: dayValid(d)
    pre yearIsValid: yearValid(y)
    post returnValueIsAccurate: result =
        (isLeapYear(y) implies d <= 29) and
        (not isLeapYear(y) implies d <= 28)

    isValid(d: Integer, m: Integer, y: Integer): Boolean =
        dayValid(d) and monthValid(m) and yearValid(y) and
        dayAndMonthValid(d, m) and (m = 2 implies febValid(d, y))
end -- Date Class

-- class Time
-- attributes
--     hours: Integer
--     minutes: Integer
--     seconds: Integer
-- end

-- this  is a test

class Player < Identifiable
attributes
    username: String
    email: String
    dob: Date
    score: Integer -- derived
    status: PlayerStatus
    state: ProfileState
end -- Player Class

class Message < Identifiable
attributes
    message: String
    date: Date --should be time 
    -- timestamp: Time
    -- status: MessageStatus
end -- Message Class

class Chat
-- attributes
--     chatstatus: ChatStatus
--     lastopened: Time or Date?
end -- Chat Class

-- class Notification
-- attributes
--     type: NotificationType
--     deliverytime: Time
-- end

class Request < Identifiable
attributes
    status: RequestStatus init: #PENDING
    sentDate: Date
    addressedDate: Date
    recindedDate: Date
    type: RequestType
end -- Request Class

class MatchRequest < Request
attributes
    matchType: MatchType
    timed: Boolean
end -- MatchRequest Class

associationclass Block
between
    Player[*] role player
    Player[*] role blocked
attributes
    date: Date
    status: BlockStatus
end -- Block Association Class

-------------------Game-------------------

associationclass Rack
between
    Player[2] role players
    Match[*] role matchHistory ordered
end -- Rack Association Class

class Play < Identifiable
attributes
    type: PlayType
    startRow: Integer
    startCol: Integer
    endRow: Integer
    endCol: Integer
    score: Integer --/score: Integer
    time: Integer -- Time in seconds between match start and this play
    bonusApplied: Boolean
end -- Play Class

class Board
attributes
end -- Board Class

class Slot
attributes
    row: Integer
    column: Integer
end -- Slot Class

class Tile
attributes
    points: Integer
end -- Tile Class

class Letter
attributes
    letter: String
end -- Letter Class

class LetterBag
end -- LetterBag Class

class Word
attributes
    String: Word
    category:  Category
end -- Word Class

class Dictionary
end -- Dictionary Class

class Match < Identifiable
attributes
    type: MatchType
    timed: Boolean
    time: Integer -- Elapsed seconds
    date: Date
    category: Category
    status: MatchStatus
end -- Match Class

class Leaderboard
end -- Leaderboard Class

associationclass Rank
between
    Leaderboard[1]
    Player[*] role players ordered
attributes
    placement: Integer
end -- Rank Association Class

---------------Associations---------------

composition PlayerChat between
    Chat[1] role chat
    Message[*] role messages ordered
end -- End PlayerChat Composition

association ChatRooms between
    Chat[*] role chatRooms
    Player[2] role participants
end -- End ChatRooms Association

association SentRequest between
    Player[1] role reqSender
    Request[*] role sentReqs
end -- End SentRequest Association

association RecievedRequest between
    Player[1] role reqRcvr
    Request[*] role rcvdReqs
end -- End RecievedRequest Association

association RequestMatch between
    MatchRequest[1] role matchReq
    Match[0..1]
end -- End RequestMatch Association

association SentMessage between
    Player[1] role msgSender
    Message[*] role sentMsgs
end -- End SentMessage Association

association RecievedMessage between
    Player[1] role msgRcvr
    Message[*] role rcvdMsgs
end -- End RecievedMessage Association



association Observes between
    Leaderboard[1] role observer
    Match[*] role watches
end -- End Observes Association

association MatchGameBoard between
    Match[1]
    Board[1]
end -- End MatchGameBoard Association

composition Grid between
    Board[1]
    Slot[*] role slots
end -- End Grid Composition

aggregation Fill between
    Slot[1]
    Tile[0..1]
end -- End Fill Aggregation

association LetterOptions between
    LetterBag[1]
    Board[1]
end -- End LetterOptions Association

aggregation Stock between
    LetterBag[1]
    Tile[*] role tiles
end -- End Stock Aggregation

association WordCheck between
    Match[*] role matches
    Dictionary[1]
end -- End WordCheck Association

association ValidWord between
    Dictionary[1]
    Word[*] role words
end -- End ValidWord Association

association Spelling between
    Word[*] role words
    Letter[*] role letters ordered
end -- End Spelling Association

association Spelt between
    Play[*] role plays
    Word[*] role words
end -- End Spelt Association

association Plays between
    Match[1]
    Play[*] role playHistory ordered
end -- End Plays Association

aggregation Holds between
    Rack[1]
    Tile[0..9] role tiles
end -- End Holds Aggregation

association Played between
    Rack[1]
    Play[*] role plays
end -- End Played Association

association Uses between
    Play[1]
    Tile[0..9] role tiles ordered
end -- End Uses Association

association Marked between
    Tile[*] role tiles
    Letter[1]
end -- End Marked Association

----------------Constraints---------------

constraints
context Identifiable
    -- Each item has a unique id
    inv uniqueIDs: Identifiable.allInstances->forAll(i1, i2 |
        i1 <> i2 implies i1.id <> i2.id)
-- End Identifiable Constraints

context Date
    inv dateIsValid: isValid(day, month, year)
-- End Date Constraints

context Player
    -- Each Player has a unique username
    inv uniqueUsernames: Player.allInstances->forAll(p1, p2 |
        p1 <> p2 implies p1.username <> p2.username)

    -- Matches must be ordered
    inv matchesAreOrdered: matchHistory->forAll(m |
        let
            i = matchHistory->indexOf(m),
            prevMatches = matchHistory->subOrderedSet(1, i - 1)
        in matchHistory->first() <> m implies
            prevMatches->forAll(prevM | prevM.date.before(m.date)))

    -- Blocked players can't be your friends
    inv notFriendAndBlocked:
        let
            allReqs = sentReqs->union(rcvdReqs),
            acceptedFrReqs = allReqs->select(req | req.type = #FRIEND and
                req.status = #ACCEPTED),
            friends = acceptedFrReqs.reqSender->union(acceptedFrReqs.reqRcvr)
                ->asSet()->excluding(self),
            blockedLst = block[player]
                ->select(b | b.status = #BLOCKED).blocked
        in friends->excludesAll(blocked)

    -- Cannot send requests to yourself
    inv noSelfRequests: sentReqs.reqRcvr->excludes(self)

    -- Can't exchange requests with blocked players
    inv noRequestExchangeWithBlockedPlayers:
        block[player]->select(b | b.status = #BLOCKED)->forAll(b |
            sentReqs->union(rcvdReqs)->forAll(req |
                (Set{req.reqSender, req.reqRcvr}->includes(b.blocked) and
                req.sentDate.after(b.date)) implies req.status = #LOST
        ))

    -- Players must not encounter players they have blocked in any match
    inv noMatchesWithBlockedPlayers:
        block[player]->select(b | b.status = #BLOCKED)->forAll(b |
            not matchHistory->exists(m |
                m.players->includes(b.blocked) and m.date.after(b.date)))

    -- There must not be any pending friend or message requests between a
    -- given pair of players if there exists an accepted request of the same
    -- type between them
    inv noPendingFriendOrMsgReqsIfAccepted:
        let
            allReqs = sentReqs->union(rcvdReqs),
            frAndMsgReqs = allReqs->select(req |
                Set{#FRIEND, #MESSAGE}->includes(req.type)),
            pending = frAndMsgReqs->select(req | req.status = #PENDING),
            accepted = frAndMsgReqs->select(req | req.status = #ACCEPTED)
        in pending->forAll(p | accepted->forAll(a |
            p.type = a.type implies
                (Set{p.reqSender, p.reqRcvr} -
                    Set{a.reqSender, a.reqRcvr})->size() > 0
        ))

    -- For a given pair or players, there may not be any pending or accepted
    -- message requests between them if there exists an accepted friend
    -- request between them
    inv noActiveMsgReqIfFriendReqAccepted:
        let
            allReqs = sentReqs->union(rcvdReqs),
            frReqs = allReqs->select(req | req.type = #FRIEND and
                req.status = #ACCEPTED),
            msgReqs = allReqs->select(req | req.type = #MESSAGE and
                Set{#PENDING, #ACCEPTED}->includes(req.status))
        in frReqs->forAll(f | not msgReqs->exists(m |
            Set{f.reqSender, f.reqRcvr} = Set{m.reqSender, m.reqRcvr}
        ))

    -- For a given pair or players, there must not be any pending or accepted
    -- message requests between them if there exists an accepted friend
    -- request between them
    inv onlyOneAcceptedMsgOrFriendReqPerPair:
        let
            acceptedReqs = sentReqs->union(rcvdReqs)->select(req |
                req.status = #ACCEPTED and
                Set{#FRIEND,#MESSAGE}->includes(req.type))
        in acceptedReqs->forAll(a1 | not acceptedReqs->exists(a2 |
            a1 <> a2 and a1.type = a2.type and
                Set{a1.reqSender, a1.reqRcvr} = Set{a2.reqSender, a2.reqRcvr}
        ))

    -- Can only exchange match requests among friends
    inv onlyFriendsExchangeMatchRequests:
        let
            allReqs = sentReqs->union(rcvdReqs),
            frReqs = allReqs->select(req | req.type = #FRIEND and
                Set{#ACCEPTED, #RECINDED}->includes(req.status)),
            matchReqs = allReqs->select(req | req.type = #MATCH)
        in matchReqs->forAll(mr | frReqs->exists(fr |
            Set{fr.reqSender, fr.reqRcvr} = Set{mr.reqSender, mr.reqRcvr} and
                ((fr.status = #ACCEPTED and
                    mr.sentDate.after(fr.addressedDate)) or
                (fr.status = #RECINDED and
                    mr.sentDate.after(fr.addressedDate) and
                    mr.sentDate.before(fr.recindedDate))
                )
        ))

    -- Can only chat if one player has accepted a message or friend request
    -- from the other player
    inv onlyChatIfRequestAccepted:
        let
            allReqs = sentReqs->union(rcvdReqs),
            frAndMsgReqs = allReqs->select(req |
                Set{#FRIEND, #MESSAGE}->includes(req.type) and
                Set{#ACCEPTED, #RECINDED}->includes(req.status))
        in rcvdMsgs->forAll(m | frAndMsgReqs->exists(req |
            Set{req.reqSender, req.reqRcvr} = Set{m.msgSender, m.msgRcvr} and
                ((req.status = #ACCEPTED and
                    m.date.after(req.addressedDate)) or
                (req.status = #RECINDED and
                    m.date.after(req.addressedDate) and
                    m.date.before(req.recindedDate))
                )
        ))

    -- players in match must have status in game
    inv playerStatusConsistent:
        if matchHistory->any(m | m.status = #INPROGRESS) <> null then
            status = #PLAYING
        else
            status <> #PLAYING
        endif

    -- Can't play more than one match at a time
    inv onlyPlayingOneOrNoMatches:
        matchHistory->select(m | m.status = #INPROGRESS)->size() <= 1
-- End Player Constraints

context Chat
    -- Chats can only have 2 participants
    inv onlyTwoParticipants:
        let
            senders = messages.msgSender->asSet(),
            recipients = messages.msgRcvr->asSet()
        in participants->includesAll(senders) and
            participants->includesAll(recipients)

    -- Messages must be ordered
    inv messagesAreOrdered: messages->forAll(m |
        let
            i = messages->indexOf(m),
            previousMsgs = messages->subOrderedSet(1, i - 1)
        in messages->first() <> m implies
            previousMsgs->forAll(prevM | prevM.date.before(m.date)))
-- End Chat Constraints

context Message
    -- Each message must have a date
    inv hasDate: date.oclIsKindOf(Date)

    -- Messages must have a body
    inv noEmptyMsgs: message.size() > 0
-- End Message Constraints

context Request
    -- Each request must have a sent date
    inv hasSentDate: sentDate.oclIsKindOf(Date)

    -- For each type of request, ther can only be one pending request between
    -- each unique pair of players.
    inv onlyOnePendingReqPerPlayerPair:
        let
            pending = Request.allInstances->select(req |
                req.status = #PENDING)
        in pending->forAll(r1, r2 |
            (r1 <> r2 and r1.type = r2.type) implies (
                (r1.reqSender <> r2.reqSender and r1.reqRcvr <> r2.reqRcvr) or
                (r1.reqSender <> r2.reqRcvr and r1.reqSender <> r2.reqRcvr))
        )
-- End Request Constraints

context MatchRequest
    -- All match requests have the type #MATCH
    inv matchReqTypeIsMatchReq: type = #MATCH

    -- Only accepted match requests may refer to a match
    inv noMatchUnlessAccepted:
        if status = #ACCEPTED then
            match->size() = 1
        else
            match->size() = 0
        endif

    -- Players may not request ranked matches
    inv noRankedMatchRequests: matchType <> #RANKED

    -- Accepted match type must match requested match type
    inv matchTypeMatchesRequestedMatchType: status = #ACCEPTED implies
        ((matchType = match.type) and (timed = match.timed))
-- End MatchRequest Constraints

context Play
    -- Plays can only go in one direction
    inv oneDirection:
        (startRow = endRow and (endCol - startCol) >= 0) or
        (startCol = endCol and (endRow - startRow) >= 0)

    -- Words must intersect or be spelt right alongside existing words
    -- or from the center of the board if all slots are empty
    inv intersectsWithAnotherWord:
        (startRow = endRow and match.board.slots->select(s |
            (Set{startRow - 1, startRow + 1}->includes(s.row) and
                s.column >= startCol and s.column <= endCol)
            or
            (s.row = startRow and
                Set{startCol - 1, endCol + 1}->includes(s.column))
            ).tile->notEmpty()
        ) or
        (startCol = endCol and match.board.slots.select(s |
            (Set{startCol - 1, startCol + 1}->includes(s.column) and
                s.row >= startRow and s.column <= endRow)
            or
            (s.column = startCol and
                Set{startRow - 1, endRow + 1}->includes(s.row))
            ).tile->notEmpty()
        )

    -- Passed plays or match quits cant have any tiles
    inv passedPlayHasNoTiles: Set{#PASS, #QUIT}->includes(type) implies
        tiles->isEmpty()

    -- Only valid words may be spelt
    inv allWordsSpeltAreValidAndOnlySpeltWordsAreLinked:
        if type = #PLAY then
            if startRow = endRow then
                let
                    allSlots = match.board.slots,

                    -- Get all slots in the play range and slots adjoining
                    -- each end
                    mainWordSlots = allSlots->select(s |
                        s.row = startRow and s.column >= (startCol - 1) and
                        s.column <= (endCol + 1))->sortedBy(s | s.column
                    ),

                    mainWord = mainWordSlots->iterate(s; word:String = ''|
                        if s.tile->isEmpty() then
                            if s.column >= startCol and s.column <= endCol then
                                let
                                    slotIndex = mainWordSlots->indexOf(s),
                                    visitedSlots = mainWordSlots
                                        ->subSequence(1, slotIndex),
                                    nextLetter = visitedSlots
                                        ->iterate(ws; ans:Integer = 0 |
                                            if ws.tile->isEmpty() then
                                                ans + 1
                                            else ans endif
                                        )
                                in word.concat(tiles
                                    ->at(nextLetter).letter.letter)
                            else word endif
                        else
                            word.concat(s.tile.letter.letter)
                        endif
                    ),

                    secondaryWordsStart = mainWordSlots->select(s |
                        let
                            adjAbove = allSlots->select(as |
                                as.row = (s.row - 1) and as.column = s.column),
                            adjBelow = allSlots->select(as |
                                as.row = (s.row + 1) and as.column = s.column)
                        in s.tile->isEmpty() and s.column >= startCol and
                            s.column <= endCol and
                            (adjAbove.tile->isEmpty() and
                                adjBelow.tile->notEmpty()) or
                            (adjBelow.tile->isEmpty() and
                                adjAbove.tile->notEmpty())
                    ),

                    secondaryWords = secondaryWordsStart
                        .iterate(s; wordLst:Set(String) = Set{} |
                            let
                                complete = false,

                                above = allSlots->select(as |
                                    as.row = (s.row - 1) and
                                    as.column = s.column).tile->notEmpty(),

                                wordSlots = allSlots->select(ws |
                                    if above and ws.column = s.column then
                                        ws.row >= s.row
                                    else
                                        ws.row <= s.row
                                    endif
                                )->sortedBy(ws | ws.row),

                                wordSlots = if above then
                                        wordSlots->reverse()
                                    else wordSlots endif
                            in wordLst->including(wordSlots
                                ->iterate(ws; word:String = '' |
                                    let
                                        complete = ws.tile->isEmpty()
                                    in
                                        if not complete then
                                            if not above then
                                                word.concat(ws.tile.letter.letter)
                                            else
                                                ws.tile.letter.letter.concat(word)
                                            endif
                                        else word endif
                                )
                            )
                        ),

                    allSpeltWords = secondaryWords->including(mainWord),

                    allValidWords = match.dictionary.words
                        ->iterate(w; wSet:Set(String) = Set{} |
                            wSet->including(w.letters
                                ->iterate(l; wordStr:String = '' |
                                    wordStr.concat(l.letter)
                                )
                            )
                        ),

                    allLinkedWords = words
                        ->iterate(w; wSet:Set(String) = Set{} |
                            wSet->including(w.letters
                                ->iterate(l; wordStr:String = '' |
                                    wordStr.concat(l.letter)
                                )
                            )
                        )
                in allValidWords->includesAll(allSpeltWords) and
                    allSpeltWords->includesAll(allLinkedWords)
            else false endif
            or
            if startCol = endCol then
                let
                    allSlots = match.board.slots,

                    -- Get all slots in the play range and slots adjoining
                    -- each end
                    mainWordSlots = allSlots->select(s |
                        s.column = startCol and s.row >= (startRow - 1) and
                        s.row <= (endRow + 1))->sortedBy(s | s.row),

                    mainWord = mainWordSlots->iterate(s; word:String = ''|
                        if s.tile->isEmpty() then
                            if s.row >= startRow and s.row <= endRow then
                                let
                                    slotIndex = mainWordSlots->indexOf(s),
                                    visitedSlots = mainWordSlots
                                        ->subSequence(1, slotIndex),
                                    nextLetter = visitedSlots
                                        ->iterate(ws; ans:Integer = 0 |
                                            if ws.tile->isEmpty() then
                                                ans + 1
                                            else ans endif)
                                in word.concat(tiles
                                    ->at(nextLetter).letter.letter)
                            else word endif
                        else
                            word.concat(s.tile.letter.letter)
                        endif
                    ),

                    secondaryWordsStart = mainWordSlots->select(s |
                        let
                            adjAbove = allSlots->select(as |
                                as.column = (s.column - 1) and as.row = s.row),
                            adjBelow = allSlots->select(as |
                                as.column = (s.column + 1) and as.row = s.row)
                        in s.tile->isEmpty() and s.row >= startRow and
                            s.row <= endRow and
                            (adjAbove.tile->isEmpty() and
                                adjBelow.tile->notEmpty()) or
                            (adjBelow.tile->isEmpty() and
                                adjAbove.tile->notEmpty())
                    ),

                    secondaryWords = secondaryWordsStart
                        .iterate(s; wordLst:Set(String) = Set{} |
                            let
                                complete = false,

                                above = allSlots->select(as |
                                    as.column = (s.column - 1) and
                                    as.row = s.row).tile->notEmpty(),

                                wordSlots = allSlots->select(ws |
                                    if above and ws.row = s.row then
                                        ws.column >= s.column
                                    else
                                        ws.column <= s.column
                                    endif
                                )->sortedBy(ws | ws.column),

                                wordSlots = if above then
                                        wordSlots->reverse()
                                    else wordSlots endif
                            in wordLst->including(wordSlots
                                ->iterate(ws; word:String = '' |
                                    let
                                        complete = ws.tile->isEmpty()
                                    in
                                        if not complete then
                                            if not above then
                                                word.concat(ws.tile.letter.letter)
                                            else
                                                ws.tile.letter.letter.concat(word)
                                            endif
                                        else word endif
                                )
                            )
                        ),

                    allSpeltWords = secondaryWords->including(mainWord),

                    allValidWords = match.dictionary.words
                        ->iterate(w; wSet:Set(String) = Set{} |
                            wSet->including(w.letters
                                ->iterate(l; wordStr:String = '' |
                                    wordStr.concat(l.letter)
                                )
                            )
                        ),

                    allLinkedWords = words
                        ->iterate(w; wSet:Set(String) = Set{} |
                            wSet->including(w.letters
                                ->iterate(l; wordStr:String = '' |
                                    wordStr.concat(l.letter)
                                )
                            )
                        )
                in allValidWords->includesAll(allSpeltWords) and
                    allSpeltWords->includesAll(allLinkedWords)
            else false endif
        else true endif

    -- Verify that a bonus is to be applied
    inv bonusCorrectlyFlagged:
        words.category->includes(match.category) and bonusApplied

    -- Score calculation verification
    inv scoreCorrectlyCalculated:
        let
            multiplier = if bonusApplied then 1.5 else 1 endif,
            tiles = rack.tiles->union(match.board.slots.tile)->asSet(),
            flatScore = words->iterate(w; ans:Integer = 0 |
                    ans + w.letters->iterate(l; ws:Integer = 0 |
                        ws + tiles->any(t | t.letter.letter = l.letter).points
                    )
                )
        in score = if bonusApplied then
                (flatScore * multiplier)
            else flatScore endif
-- End Play Constraints

context Board
    -- Must have 15 by 15 slots
    inv boardSizeIsValid: slots->forAll(s |
        s.row > 0 and s.row <= 15 and s.column > 0 and s.column <= 15)
-- End Board Constraints

context Tile
    -- Ensure Tiles have a valid point value
    inv validPoints: points > 0 and points <= 10
-- End Tile Constraints

context Letter
    -- Ensure that the letter is valid
    inv validLetter: Set{'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',
        'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
        'X', 'Y', 'Z'
    }->includes(letter)
-- End Letter Constraints

context Word
    -- No duplicate words
    inv uniqueWords: Word.allInstances->forAll(w1, w2 |
            if w1 <> w2 then
                let
                    word1 = w1.letters->iterate(l; word:String = '' |
                        word.concat(l.letter)),
                    word2 = w2.letters->iterate(l; word:String = '' |
                        word.concat(l.letter))
                in not word1.equalsIgnoreCase(word2)
            else true endif
        )
-- End Word Constraints

context Dictionary
    -- Only one dictionary for the lifecycle of the system
    inv onlyOneDictionaryInstance: Dictionary.allInstances->size() <= 1
-- End Dictionary Constraints

context Match
    -- Each match must have a date
    inv hasDate: date.oclIsKindOf(Date)

    -- Only unranked matches may be untimed
    inv noUntimedRankedMatches: (type = #RANKED) implies timed

    -- Plays must be ordered
    inv playsAreOrdered: playHistory->forAll(p |
        let
            i = playHistory->indexOf(p),
            previousPlays = playHistory->subOrderedSet(1, i - 1)
        in playHistory->first() <> p implies
            previousPlays->forAll(prevP | prevP.time < p.time))

    -- First word must be spelt in the center
    inv firstPlayStartsAtCentre:
        let
            firstPlay = playHistory->first()
        in (firstPlay.startRow = 8 and firstPlay.startCol = 8)

    -- Plays must alternate between players, ie the game should be turn based
    inv playsAlternateBetweenPlayers:
        let
            player1 = playHistory->at(1).rack.players,
            player2 = playHistory->at(2).rack.players
        in playHistory->forAll(p |
            if playHistory->indexOf(p).mod(2) = 1 then
                player1 = p.rack.players
            else
                player2 = p.rack.players
            endif
        )

    -- Ensure all Tiles with the same letter have the same score
    inv consistentTilePointValues:
        let
            bagTiles = board.letterBag.tiles,
            rackTiles = rack.tiles,
            boardTiles = board.slots.tile,
            allTiles = bagTiles->union(rackTiles->union(boardTiles))
        in allTiles->forAll(t1, t2|
            t1.letter.letter = t2.letter.letter implies t1.points = t2.points)

    -- must be a fixed set of tiles in circulation for a given match
    inv fixedNumberOfLettersInMatch:
        let
            bagLetters = board.letterBag.tiles.letter,
            rackLetters = rack.tiles.letter,
            boardLetters = board.slots.tile.letter,
            allTiles = bagLetters->union(rackLetters->union(boardLetters)),
            a = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('A') then cnt + 1 else cnt endif),
            b = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('B') then cnt + 1 else cnt endif),
            c = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('C') then cnt + 1 else cnt endif),
            d = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('D') then cnt + 1 else cnt endif),
            e = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('E') then cnt + 1 else cnt endif),
            f = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('F') then cnt + 1 else cnt endif),
            g = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('G') then cnt + 1 else cnt endif),
            h = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('H') then cnt + 1 else cnt endif),
            i = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('I') then cnt + 1 else cnt endif),
            j = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('J') then cnt + 1 else cnt endif),
            k = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('K') then cnt + 1 else cnt endif),
            l = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('L') then cnt + 1 else cnt endif),
            m = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('M') then cnt + 1 else cnt endif),
            n = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('N') then cnt + 1 else cnt endif),
            o = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('O') then cnt + 1 else cnt endif),
            p = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('P') then cnt + 1 else cnt endif),
            q = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('Q') then cnt + 1 else cnt endif),
            r = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('R') then cnt + 1 else cnt endif),
            s = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('S') then cnt + 1 else cnt endif),
            t = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('T') then cnt + 1 else cnt endif),
            u = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('U') then cnt + 1 else cnt endif),
            v = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('V') then cnt + 1 else cnt endif),
            w = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('W') then cnt + 1 else cnt endif),
            x = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('X') then cnt + 1 else cnt endif),
            y = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('Y') then cnt + 1 else cnt endif),
            z = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('Z') then cnt + 1 else cnt endif)
        in (a = 9 and b = 2 and c = 2 and d = 4 and e = 12 and f = 2 and
            g = 3 and h = 2 and i = 9 and j = 1 and k = 1 and l = 4 and
            m = 2 and n = 6 and o = 8 and p = 2 and q = 1 and r = 6 and
            s = 4 and t = 6 and u = 4 and v = 2 and w = 2 and x = 1 and
            y = 2 and z = 1)

    -- Players must be similar rank
    inv similarRank:
        players.rank->forAll(p1, p2 |
            (type = #RANKED and (p1.placement - p2.placement).abs() <= 100) or
            (matchReq->size() = 0 implies
                (p1.placement - p2.placement).abs() <= 200)
        )

    -- Once a player quits the match must end
    inv matchEndIfQuit:
        (playHistory->select(p | p.type = #QUIT)->size() <= 1 implies
            playHistory->last().type = #QUIT) and
        playHistory->last().type = #QUIT implies status = #ABANDONED

    -- Once a match ends no additional plays can be made
    inv noPlaysAfterMatchEnd:
        status = #ABANDONED implies playHistory->last().type = #QUIT and
        status = #COMPLETE implies playHistory->forAll(p | p.time < time)

    -- Matches can't last longer than 5 min
    inv matchEndTimeValid:
        (timed and Set{#COMPLETE, #ABANDONED}->includes(status)) implies
            (time > 0 and time < 300) -- 5 min
-- End Match Constraints

context Leaderboard
    -- Only one Leaderboard for the lifetime of the system
    inv onlyOneLeaderboardInstance: Leaderboard.allInstances->size() <= 1

    -- All ranks are ordered
    inv ranksAreAccurateAndOrdered:
        rank->forAll(r |
            let
                i = rank->indexOf(r),
                higherRanks = rank->subOrderedSet(1, i - 1)
            in rank->first() <> r implies
                higherRanks->forAll(upperR |
                    (upperR.placement < r.placement and
                        upperR.players.score > r.players.score) or
                    (upperR.placement = r.placement and
                        upperR.players.score = r.players.score)
                ) and
                higherRanks.placement->asSet()->excludes(r.placement) implies
                    r.placement = i
        )
-- End Leaderboard Constraints

-- End All Constraints
