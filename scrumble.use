model scrumble --name of model

enum PlayerStatus {Online, Offline, Away, Playing}
enum ProfileState {Private, Public}
enum MatchType {RANKED, UNRANKED}
enum Category {animal, music, movies, food, books, countries, none}
enum PlayType {PLAY, PASS}
enum RequestStatus {PENDING, ACCEPTED, REJECTED, RECINDED, LOST}
enum MatchStatus {INPROGRESS, COMPLETE, ABANDONED}
enum RequestType {FRIEND, MESSAGE, MATCH}
enum BlockStatus {BLOCKED, UNBLOCKED}


class Identifiable
attributes
    id: String
constraints
    -- Each item has a unique id
    inv uniqueIDs: Identifiable.allInstances->forAll(i1, i2 |
        i1 <> i2 implies i1.id <> i2.id)
end -- Identifiable

--from Class
class Date
attributes
    day: Integer init: 1
    month: Integer init: 1
    year: Integer init: 1900
operations
    initialise(d: Integer, m: Integer, y: Integer)
    begin
        self.day := d;
        self.month := m;
        self.year := y;
    end

    pre parametersHaveValidValues: isValid(d, m, y)
    post attributesCorrectlyUpdated: 
        day = d and month = m and year = y

    -- Accessors
    getDay(): Integer = day
    getMonth(): Integer = month
    getYear(): Integer = year

    -- Mutators
    setDay(d: Integer)
    begin self.day := d; end
    pre newDateIsValid: isValid(d, month, year)
    post dayCorrectlyUpdated: day = d

    setMonth(m: Integer)
    begin self.month := m; end
    pre newDateIsValid: isValid(day, m, year)
    post monthCorrectlyUpdated: month = m

    setYear(y: Integer)
    begin self.year := y; end
    pre newDateIsValid: isValid(day, month, y)
    post yearCorrectlyUpdated: year = y

    -- returns true if all the attributes are not null, false otherwise
    isInitialised(): Boolean = day <> null and month <> null and
        year <> null
    post returnValueIsAccurate:
        result = Set{day <> null, month <> null, year <> null}->forAll(t | t = true)

    -- returns true if self is before d, false otherwise
    before(d: Date): Boolean = ((year < d.year) or
        (year = d.year and month < d.month) or
        (year = d.year and month = d.month and day < d.day))
    pre bothAreInitialised: isInitialised() and d.isInitialised()
    pre bothAreValid: isValid(day, month, year) and
        isValid(d.day, d.month, d.year)
    post returnValueIsAccurate:
        result = ((year < d.year) or
            (year = d.year and month < d.month) or
            (year = d.year and month = d.month and day < d.day)) = true

    -- returns true if self has the same values as d, false otherwise
    equals(d: Date): Boolean = day = d.day and month = d.month and
        year = d.year
    pre bothAreInitialised: isInitialised() and d.isInitialised()
    pre bothAreValid: isValid(day, month, year) and
        isValid(d.day, d.month, d.year)
    post returnValueConditions:
        result = Set{day = d.day, month = d.month, year = d.year}->forAll(t | t = true)

    -- returns true if self is after d, false otherwise
    after(d: Date): Boolean = (not equals(d)) and (not before(d))
    pre bothAreInitialised: isInitialised() and d.isInitialised()
    pre bothAreValid: isValid(day, month, year) and
        isValid(d.day, d.month, d.year)
    post returnValueIsAccurate:
        result = Set{not equals(d), not before(d)}->forAll(t | t = true)

    -- returns true if y is a leap year, false otherwise
    isLeapYear(y: Integer): Boolean = 
        if (y.mod(400) = 0 or (y.mod(100) > 0 and y.mod(4) = 0)) then
                true
            else
                false
            endif
    pre yearIsValid: y <> null and y > 1900
    post returnValueIsAccurate: result = (y.mod(400) = 0 or
        (y.mod(100) > 0 and y.mod(4) = 0)) = true

    dayValid(v: Integer): Boolean = v >= 1 and v <= 31
    pre paramaterNotNull: v <> null
    post returnValueIsAccurate: result = v >= 1 and v <= 31

    monthValid(v: Integer): Boolean = v >= 1 and v <= 12
    pre paramaterNotNull: v <> null
    post returnValueIsAccurate: result = v >= 1 and v <= 12

    yearValid(v: Integer): Boolean = v > 1900
    pre paramaterNotNull: v <> null
    post returnValueIsAccurate: result = v > 1900

    dayAndMonthValid(d: Integer, m: Integer): Boolean =
        (Set{4, 6, 9, 11}->includes(m) implies d <= 30) and
        (Set{1, 3, 5, 7, 8, 10, 12}->includes(m) implies d <= 31)
    pre dayIsValid: dayValid(d)
    pre monthIsValid: monthValid(m)
    post returnValueIsAccurate: result =
        (Set{4, 6, 9, 11}->includes(m) implies d < 31) and
        (Set{1, 3, 5, 7, 8, 10, 12}->includes(m) implies d < 32)

    febValid(d: Integer, y: Integer): Boolean =
        (isLeapYear(y) implies d <= 29) and 
        (not isLeapYear(y) implies d <= 28)
    pre dayIsValid: dayValid(d)
    pre yearIsValid: yearValid(y)
    post returnValueIsAccurate: result =
        (isLeapYear(y) implies d <= 29) and 
        (not isLeapYear(y) implies d <= 28)

    isValid(d: Integer, m: Integer, y: Integer): Boolean =
        dayValid(d) and monthValid(m) and yearValid(y) and
        dayAndMonthValid(d, m) and (m = 2 implies febValid(d, y))

constraints
    inv dateIsValid: isValid(day, month, year)
end -- Date

class Player < Identifiable
attributes
    username: String
    email: String
    dob: Date
    score: Integer -- derived
    status: PlayerStatus
    state: ProfileState
constraints
    -- Blocked players can't be your friends
    inv notFriendAndBlocked:
        let
            fReqAccepted = sentReqs->select(req |
                req.type = #FRIEND and req.status = #ACCEPTED).reqRcvr,
            acceptedFReq = rcvdReqs->select(req |
                req.type = #FRIEND and req.status = #ACCEPTED).reqRcvr,
            friends = fReqAccepted->union(acceptedFReq)
        in friends->excludesAll(blocked)

    -- Cannot send requests to yourself
    inv noSelfRequests: sentReqs.reqRcvr->excludes(self)

    -- Can't receive requests from blocked players
    inv notReceiveRequestsFromBlocked:
        let
            blocks = block[player]->select(b | b.status = #BLOCKED)
        in blocks->forAll(b |
            let
                requests = rcvdReqs->select(r |
                    r.sentDate.after(b.date) and r.reqSender = b.blocked)
            in requests->forAll(req | req.status = #LOST)
        )

    -- Can't send requests to blocked players
    inv notSendRequestsToBlocked:
        let
            blocks = block[player]->select(b | b.status = #BLOCKED)
        in blocks->forAll(b | sentReqs->select(r |
            r.sentDate.after(b.date) and r.reqRcvr = b.blocked)->isEmpty()
        )

    -- #TODO
    -- Can only exchange match requests among friends
    --inv onlyFriendsExchangeMatchRequests:
    --    let
    --        fReqAccepted = sentReqs->select(req |
    --            req.type = #FRIEND and req.status = #ACCEPTED).reqRcvr,
    --        acceptedFReq = rcvdReqs->select(req |
    --            req.type = #FRIEND and req.status = #ACCEPTED).reqRcvr,
    --        friends = fReqAccepted->union(acceptedFReq)->asSet(),
    --        rcvdMatchReqs = rcvdReqs->select(req | req.type = #MATCH),
    --        validMatchReq = rcvdMatchReqs->select(mr |
    --                friends->includes(mr.reqSender) and
    --                mr.date.after(mr.reqSender.sentReqs->sel())
    --            )
    --    in rcvdMatchReqs->forAll(mr | req.reqSender)

    -- The association between Player and Match would basically create
    -- an attribute in player named the role name match has (matchHistory)
    -- and would be an array of matches and in the match class there's be
    -- an attribute named as the player's role (players) that's an array
    -- [of 2] players

    -- Can only chat if one player has accepted a message or friend request
    -- from the other player
    --inv onlyChatIfRequestAccepted:
    --    let
    --        senderFriends = msgSender.sentReqs->select(r |
    --            r.type = #FRIEND and r.status = #ACCEPTED).reqRcvr->union(
    --                msgSender.rcvdReqs->select(r |
    --                    r.type = #FRIEND and r.status = #ACCEPTED).reqSender),
    --        rcvrFriends = msgRcvr.sentReqs->select(r |
    --            r.type = #FRIEND and r.status = #ACCEPTED).reqRcvr->union(
    --                msgRcvr.rcvdReqs->select(r |
    --                    r.type = #FRIEND and r.status = #ACCEPTED).reqSender)
    --    in senderFriends->includes(msgRcvr) or 
    --        rcvrFriends->includes(msgSender)

    -- Can't play more than one match at a time
    inv onlyPlayingOneOrNoMatches:
        matchHistory->select(m | m.status = #INPROGRESS)->size() <= 1
end -- Player

class Message < Identifiable
attributes
    message: String
    date: Date --should be time
end -- Message

class Chat
constraints
    -- Chats can only have 2 participants
    inv onlyTwoParticipants:
        let
            senders = messages.msgSender->asSet(),
            recipients = messages.msgRcvr->asSet()
        in participants->includesAll(senders) and 
            participants->includesAll(recipients)

    -- Messages must be ordered
    inv messagesAreOrdered: messages->forAll(m |
        let
            i = messages->indexOf(m),
            previousMsgs = messages->subOrderedSet(0, i)
        in messages->first() <> m implies
            previousMsgs->forAll(prevM | prevM.date.before(m.date)))
end -- Chat

class Request < Identifiable
attributes
    status: RequestStatus --= #PENDING
    sentDate: Date
    type: RequestType
constraints
    -- For each type of request, senders can only have one pending request
    -- per receiver
    inv onlyOnePendingReqPerSenderReceiverReqTypeTuple:
        let
            pending = Request.allInstances->select(req | req.status = #PENDING)
        in pending->forAll(r1, r2 | r1 <> r2 implies
            (r1.reqSender <> r2.reqSender or r1.reqRcvr <> r2.reqRcvr))

    -- Can only have one friend or message request pending per sender-receiver
    -- paring
    inv onlyOnePendingMsgFrReqPerPair:
        let
            pending = Request.allInstances->select(req | req.status = #PENDING and
                Set{#FRIEND, #MESSAGE}->includes(req.type))
        in pending->forAll(r1, r2 |
            r1.reqSender <> r2.reqRcvr or r1.reqRcvr <> r2.reqSender)

    -- Can only accept one friend or message request
    inv onlyOneAcceptedFriendOrMessageRequest:
        let
            pending = Request.allInstances->select(req | req.status = #ACCEPTED and
                Set{#FRIEND, #MESSAGE}->includes(req.type))
        in pending->forAll(r1, r2 | r1 <> r2 implies
            (r1.reqSender <> r2.reqSender or r1.reqRcvr <> r2.reqRcvr))

    -- Can't send any new friend or message requests to a player if
    -- they already accepted the last one
    inv noPendingRequestsIfAccepted:
        let
            frAndMsgReqs = Request.allInstances->select(req |
                Set{#FRIEND, #MESSAGE}->includes(req.type)),
            pending = frAndMsgReqs->select(req | req.status = #PENDING),
            accepted = frAndMsgReqs->select(req | req.status = #ACCEPTED)
        in pending->forAll(p | accepted->forAll(a | 
            p.reqSender <> a.reqSender or p.reqRcvr <> a.reqRcvr))
end -- Request

class MatchRequest < Request
attributes
    matchType: MatchType
    timed: Boolean
constraints
    -- All message requests have the type #MESSAGE
    inv messageReqTypeIsMsgReq:
        MatchRequest.allInstances->forAll(mr | mr.type = #MESSAGE)

    -- Only accepted match requests may refer to a match
    inv noMatchUnlessAccepted:
        MatchRequest.allInstances->forAll(mr |
            (mr.status = #ACCEPTED implies mr.match->size() = 1) and
            (mr.status <> #ACCEPTED implies mr.match->size() = 0))

    -- Accepted match type must match requested match type
    inv matchTypeMatchesRequestedMatchType:
        MatchRequest.allInstances->forAll(mr |
            mr.status = #ACCEPTED implies
                (mr.matchType = mr.match.type) and mr.timed and mr.match.timed
        )

    -- Only unranked matches may be untimed
    inv noUntimedRankedMatchRequests: (matchType = #RANKED) implies timed
end -- MatchRequest

associationclass Block
between
    Player[*] role player
    Player[*] role blocked
attributes
    date: Date
    status: BlockStatus
end -- Block

-------------------Game-------------------

associationclass Rack
between
    Player[2] role players
    Match[*] role matchHistory
end -- Rack

-- maybe add a turn attribute so we can track the order better.
-- They're already ordered though so idk. Not a priority anyways

class Play < Identifiable
attributes
    type: PlayType
    startRow: Integer
    startCol: Integer
    endRow: Integer
    endCol: Integer
    score: Integer --/score: Integer
    time: Integer -- Time in seconds between match start and this play
    bonusApplied: Boolean
constraints
    -- Plays can only go in one direction
    inv oneDirection:
        (startRow = endRow implies (endCol - startCol) >= 0) and
        (startCol = endCol implies (endRow - startRow) >= 0)

    -- Words must intersect or be spelt right alongside existing words
    -- or from the center of the board if all slots are empty
    inv intersectsWithAnotherWord:
        (startRow = endRow implies match.board.slots->select(s |
            (Set{startRow - 1, startRow + 1}->includes(s.row) and
                s.column >= startCol and s.column <= endCol)
            or
            (s.row = startRow and
                Set{startCol - 1, endCol + 1}->includes(s.column))
            ).tile->notEmpty()
        ) and
        (startCol = endCol implies match.board.slots.select(s |
            (Set{startCol - 1, startCol + 1}->includes(s.column) and
                s.row >= startRow and s.column <= endRow)
            or
            (s.column = startCol and
                Set{startRow - 1, endRow + 1}->includes(s.row))
            ).tile->notEmpty()
        )

    -- Passed plays cant have any tiles
    inv passedPlayHasNoTiles: type = #PASS implies tiles->isEmpty()

    /*
    -- Only valid words may be spelt
    inv allWordsSpeltAreValidAndOnlySpeltWordsAreLinked:
        if type = #PLAY then
            if startRow = endRow then
                let
                    allSlots = match.board.slots,

                    -- Get all slots in the play range and slots adjoining each end
                    mainWordSlots = allSlots->select(s | s.row = startRow and
                        s.column >= (startCol - 1) and s.column <= (endCol + 1)),

                    nextLetter = 0,
                    mainWord = mainWordSlots->iterate(s; word:String = ''|
                        if s.tile->isEmpty() then
                            if s.column >= startCol and s.column <= endCol then
                                word.concat(tiles->at(nextLetter).letter.letter)
                                nextLetter = nextLetter + 1
                            else '' endif
                        else
                            word.concat(s.tile.letter.letter)
                        endif
                    ),

                    secondaryWordsStart = mainWordSlots->select(s |
                        let
                            adjAbove = allSlots->select(as |
                                as.row = (s.row - 1) and as.column = s.column),
                            adjBelow = allSlots->select(as |
                                as.row = (s.row + 1) and as.column = s.column)
                        in s.tile.isEmpty() and s.column >= startCol and s.column <= endCol and
                            (adjAbove.tile->isEmpty() implies adjBelow.tile->notEmpty()) and
                            (adjBelow.tile->isEmpty() implies adjAbove.tile->notEmpty())
                    ),

                    secondaryWords = secondaryWordsStart.iterate(s; wordLst:Set(String) = Set{} |
                        let
                            complete = false,

                            above = allSlots->select(as | as.row = (s.row - 1) and
                                as.column = s.column).tile->notEmpty(),

                            wordSlots = allSlots->select(ws |
                                if above and ws.column = s.column then
                                    ws.row >= s.row
                                else
                                    ws.row <= s.row
                                endif
                            )->sortedBy(ws | ws.row),

                            if above then wordSlots->reverse() endif
                        in wordLst->union(Set{wordSlots->iterate(ws; word:String = '' |
                            if ws.tile->isEmpty() then complete = true endif

                            if not complete then
                                if not above then
                                    word->concat(ws.tile.letter.letter)
                                else
                                    temp = ws.tile.letter.letter
                                    word = temp->concat(word)
                                endif
                            endif
                        )})
                    ),

                    allSpeltWords = mainWord->union(secondaryWords),

                    --allValidWords = match.dictionary.word->iterate(w; words:Set(String) = Set{} |
                    --    words->union(Set{w->iterate(l; word:String = '' |
                    --        word->concat(l.letter)
                    --    )})
                    --),
                    allValidWords = match.dictionary.word->collect(w |
                        w->iterate(l; word:String = '' | word->concat(l.letter))),

                    --allLinkedWords = words->iterate(w; words:Set(String) = Set{} |
                    --    words->union(Set{w->iterate(l; word:String = '' |
                    --        word->concat(l.letter)
                    --    )})
                    --)
                    allLinkedWords = words->collect(w |
                        w->iterate(l; word:String = '' | word->concat(l.letter))),
                in allValidWords->includesAll(allSpeltWords) and
                    allSpeltWords->includesAll(allLinkedWords)
            else true endif
            or
            if startCol = endCol then
                let
                    allSlots = match.board.slots,

                    -- Get all slots in the play range and slots adjoining each end
                    mainWordSlots = allSlots->select(s | s.column = startCol and
                        s.row >= (startRow - 1) and s.row <= (endRow + 1)),

                    nextLetter = 0,
                    mainWord = mainWordSlots->iterate(s; word:String = ''|
                        if s.tile->isEmpty() then
                            if s.row >= startRow and s.row <= endRow then
                                word.concat(tiles->at(nextLetter).letter.letter)
                                nextLetter = nextLetter + 1
                            endif
                        else
                            word.concat(s.tile.letter.letter)
                        endif
                    ),

                    secondaryWordsStart = mainWordSlots->select(s |
                        let
                            adjLeft = allSlots->select(as |
                                as.column = (s.column - 1) and as.row = s.row),
                            adjRight = allSlots->select(as |
                                as.column = (s.column + 1) and as.row = s.row)
                        in s.tile.isEmpty() and s.row >= startRow and s.row <= endRow and
                            (adjLeft.tile->isEmpty() implies adjRight.tile->notEmpty()) and
                            (adjRight.tile->isEmpty() implies adjLeft.tile->notEmpty())
                    )

                    secondaryWords = secondaryWordsStart.iterate(s; wordLst:Set(String) = Set{} |
                        let
                            complete = false,

                            left = allSlots->select(as | as.column = (s.column - 1) and
                                as.row = s.row).tile->notEmpty(),

                            wordSlots = allSlots->select(ws |
                                if left and ws.row = s.row then
                                    ws.column >= s.column
                                else
                                    ws.column <= s.column
                                endif
                            )->sortedBy(ws | ws.column),

                            if left then wordSlots->reverse() endif
                        in wordLst->union(Set{wordSlots->iterate(ws; word:String = '' |
                            if ws.tile->isEmpty() then complete = true endif

                            if not complete then
                                if not left then
                                    word->concat(ws.tile.letter.letter)
                                else
                                    temp = ws.tile.letter.letter
                                    word = temp->concat(word)
                                endif
                            endif
                        )})
                    )

                    allSpeltWords = mainWord->union(secondaryWords),

                    allValidWords = match.dictionary.word->iterate(w; words:Set(String) = Set{} |
                        words->union(Set{w->iterate(l; word:String = '' |
                            word->concat(l.letter)
                        )})
                    ),

                    allLinkedWords = words->iterate(w; words:Set(String) = Set{} |
                        words->union(Set{w->iterate(l; word:String = '' |
                            word->concat(l.letter)
                        )})
                    )
                in allValidWords->includesAll(allSpeltWords) and
                    allSpeltWords->includesAll(allLinkedWords)
            else true endif
        else true endif
    */

    -- #TODO
    -- Check to ensure that the player's match stats are updated properly
    --inv :

    -- Verify that a bonus is to be applied
    inv bonusCorrectlyFlagged:
        words.category->includes(match.category) implies bonusApplied

    -- #TODO
    -- Score calculation verification
    inv scoreCorrectlyCalculated:
        let
            multiplier = if bonusApplied then 1.5 else 1 endif,
            scoreCheck = 0
        in score = scoreCheck
end -- Play

class Board
attributes
    row: Integer
    column: Integer
constraints
    -- Must have 15 by 15 slots
    inv boardSizeIsValid: slots->forAll(s |
        s.row > 0 and s.row <= 15 and s.column > 0 and s.column <= 15)
end -- Board

class Slot
attributes
    row: Integer
    column: Integer
end -- Slot

class Tile
attributes
    points: Integer
constraints
    -- Ensure Tiles have a valid point value
    inv validPoints: points > 0 and points <= 10
end -- Tile

class Letter
attributes
    letter: String
constraints
    -- Ensure that the letter is valid
    inv validLetter: Set{'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',
        'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
        'X', 'Y', 'Z'
    }->includes(letter)
end -- Letter

class LetterBag
end -- LetterBag

class Word
attributes
    String: Word
    category:  Category
constraints
    -- No duplicate words
    inv uniqueWords: Word.allInstances->forAll(w1, w2 |
            if w1 <> w2 then
                let
                    word1 = w1.letters->iterate(l; word:String = '' |
                        word.concat(l.letter)),
                    word2 = w2.letters->iterate(l; word:String = '' |
                        word.concat(l.letter))
                in not word1.equalsIgnoreCase(word2)
            else true endif
        )
end -- Word

class Dictionary
constraints
    -- Only one dictionary for the lifecycle of the system
    inv onlyOneDictionaryInstance: Dictionary.allInstances->size() <= 1
end -- Dictionary

class Match < Identifiable
attributes
    type: MatchType
    timed: Boolean
    time: Integer -- Elapsed seconds
    date: Date
    category: Category
    status: MatchStatus
constraints
    -- Only unranked matches may be untimed
    inv noUntimedRankedMatchRequests: (type = #RANKED) implies timed

    -- Plays must be ordered
    inv playsAreOrdered: playHistory->forAll(p |
        let
            i = playHistory->indexOf(p),
            previousPlays = playHistory->subOrderedSet(0, i)
        in playHistory->first() <> p implies
            previousPlays->forAll(prevP | prevP.time < p.time))

    -- Plays must alternate between players, ie the game should be turn based
    inv playsAlternateBetweenPlayers:
        let
            player1 = playHistory->at(0).rack.players,
            player2 = playHistory->at(1).rack.players
        in playHistory->iterate(p; result:Boolean = true |
                if playHistory->indexOf(p).mod(2) = 0 then
                    result = result and (player1 = p)
                else
                    result = result and (player2 = p)
                endif
            )

    -- Ensure all Tiles with the same letter have the same score
    inv consistentTilePointValues:
        let
            bagTiles = board.letterBag.tiles,
            rackTiles = rack.tiles,
            boardTiles = board.slots.tile,
            allTiles = bagTiles->union(rackTiles->union(boardTiles))
        in allTiles->forAll(t1, t2|
            t1.letter.letter = t2.letter.letter implies t1.points = t2.points)

    -- must be a fixed set of tiles in circulation for a given match
    inv fixedNumberOfLettersInMatch:
        let
            bagLetters = board.letterBag.tiles.letter,
            rackLetters = rack.tiles.letter,
            boardLetters = board.slots.tile.letter,
            allTiles = bagLetters->union(rackLetters->union(boardLetters)),
            a = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('A') then cnt + 1 else cnt endif),
            b = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('B') then cnt + 1 else cnt endif),
            c = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('C') then cnt + 1 else cnt endif),
            d = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('D') then cnt + 1 else cnt endif),
            e = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('E') then cnt + 1 else cnt endif),
            f = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('F') then cnt + 1 else cnt endif),
            g = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('G') then cnt + 1 else cnt endif),
            h = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('H') then cnt + 1 else cnt endif),
            i = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('I') then cnt + 1 else cnt endif),
            j = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('J') then cnt + 1 else cnt endif),
            k = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('K') then cnt + 1 else cnt endif),
            l = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('L') then cnt + 1 else cnt endif),
            m = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('M') then cnt + 1 else cnt endif),
            n = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('N') then cnt + 1 else cnt endif),
            o = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('O') then cnt + 1 else cnt endif),
            p = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('P') then cnt + 1 else cnt endif),
            q = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('Q') then cnt + 1 else cnt endif),
            r = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('R') then cnt + 1 else cnt endif),
            s = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('S') then cnt + 1 else cnt endif),
            t = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('T') then cnt + 1 else cnt endif),
            u = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('U') then cnt + 1 else cnt endif),
            v = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('V') then cnt + 1 else cnt endif),
            w = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('W') then cnt + 1 else cnt endif),
            x = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('X') then cnt + 1 else cnt endif),
            y = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('Y') then cnt + 1 else cnt endif),
            z = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('Z') then cnt + 1 else cnt endif)
        in (a = 9 and b = 2 and c = 2 and d = 4 and e = 12 and f = 2 and
            g = 3 and h = 2 and i = 9 and j = 1 and k = 1 and l = 4 and
            m = 2 and n = 6 and o = 8 and p = 2 and q = 1 and r = 6 and
            s = 4 and t = 6 and u = 4 and v = 2 and w = 2 and x = 1 and
            y = 2 and z = 1)

    -- Players must be similar rank
    inv similarRank:
        players.rank->forAll(p1, p2 |
            type = #RANKED implies (p1.placement - p2.placement).abs() <= 100 and
            type <> #RANKED implies (p1.placement - p2.placement).abs() <= 200)
end -- Match

class Leaderboard
constraints
    -- Only one Leaderboard for the lifetime of the system
    inv onlyOneLeaderboardInstance: Leaderboard.allInstances->size() <= 1
end -- Leaderboard

associationclass Rank
between
    Leaderboard[1]
    Player[*] role players ordered
attributes
    placement: Integer
constraints
    -- #TODO
    -- Ensure correct rankings are always assigned
    -- incv :
end -- Rank

---------------Associations---------------

composition PlayerChat between
    Chat[1] role chat
    Message[*] role messages ordered
end

association ChatRooms between
    Chat[*] role chatRooms
    Player[2] role participants
end

association SentRequest between
    Player[1] role reqSender
    Request[*] role sentReqs
end

association RecievedRequest between
    Player[1] role reqRcvr
    Request[*] role rcvdReqs
end

association RequestMatch between
    MatchRequest[1] role matchReq
    Match[0..1]
end

association SentMessage between
    Player[1] role msgSender
    Message[*] role sentMsgs
end

association RecievedMessage between
    Player[1] role msgRcvr
    Message[*] role rcvdMsgs
end



association Observes between
    Leaderboard[1] role observer
    Match[*] role watches
end

association MatchGameBoard between
    Match[1]
    Board[1]
end

composition Grid between
    Board[1]
    Slot[*] role slots
end

aggregation Fill between
    Slot[1]
    Tile[0..1]
end

association LetterOptions between
    LetterBag[1] 
    Board[1]
end

aggregation Stock between
    LetterBag[1]
    Tile[*] role tiles
end

association WordCheck between
    Match[*] role matches
    Dictionary[1]
end

association ValidWord between
    Dictionary[1]
    Word[*] role words
end

association Spelling between
    Word[*] role words
    Letter[*] role letters ordered
end

association Spelt between
    Play[*] role plays
    Word[*] role words
end

association Plays between
    Match[1]
    Play[*] role playHistory ordered
end

aggregation Holds between 
    Rack[1]
    Tile[0..9] role tiles
end

association Played between
    Rack[1]
    Play[*] role plays
end

association Uses between
    Play[1]
    Tile[0..9] role tiles ordered
end

association Marked between
    Tile[*] role tiles
    Letter[1]
end
